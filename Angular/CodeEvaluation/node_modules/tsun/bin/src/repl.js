"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var readlineTTY = require("node-color-readline");
var readlineNoTTY = require("readline");
var util = require("util");
var vm = require("vm");
var console_1 = require("console");
var path = require("path");
var child_process = require("child_process");
var fs = require("fs");
var service_1 = require("./service");
var util_1 = require("./util");
var Module = require('module');
require("colors");
// node-color-readline blows up in non-TTY envs
var readline = process.stdout.isTTY ? readlineTTY : readlineNoTTY;
var options = require('optimist')
    .alias('f', 'force')
    .describe('f', 'Force tsun to evaluate code with ts errors.')
    .alias('v', 'verbose')
    .describe('v', 'Print compiled javascript before evaluating.')
    .describe('dere', "I-its's not like I'm an option so DON'T GET THE WRONG IDEA!");
var argv = options.argv;
var verbose = argv.verbose;
exports.defaultPrompt = '> ', exports.moreLinesPrompt = '..';
// a buffer for multiline editing
var multilineBuffer = '';
var rl = createReadLine();
function colorize(line) {
    var colorized = '';
    var regex = [
        [/\/\/.*$/m, 'grey'],
        [/(['"`\/]).*?(?!<\\)\1/, 'cyan'],
        [/[+-]?(\d+\.?\d*|\d*\.\d+)([eE][+-]?\d+)?/, 'cyan'],
        [/\b(true|false|null|undefined|NaN|Infinity)\b/, 'blue'],
        [/\b(in|if|for|while|var|new|function|do|return|void|else|break)\b/, 'green'],
        [/\b(instanceof|with|case|default|try|this|switch|continue|typeof)\b/, 'green'],
        [/\b(let|yield|const|class|extends|interface|type)\b/, 'green'],
        [/\b(try|catch|finally|Error|delete|throw|import|from|as)\b/, 'red'],
        [/\b(eval|isFinite|isNaN|parseFloat|parseInt|decodeURI|decodeURIComponent)\b/, 'yellow'],
        [/\b(encodeURI|encodeURIComponent|escape|unescape|Object|Function|Boolean|Error)\b/, 'yellow'],
        [/\b(Number|Math|Date|String|RegExp|Array|JSON|=>|string|number|boolean)\b/, 'yellow'],
        [/\b(console|module|process|require|arguments|fs|global)\b/, 'yellow'],
        [/\b(private|public|protected|abstract|namespace|declare|@)\b/, 'magenta'],
        [/\b(keyof|readonly)\b/, 'green'],
    ];
    while (line !== '') {
        var start = +Infinity;
        var color = '';
        var length_1 = 0;
        for (var _i = 0, regex_1 = regex; _i < regex_1.length; _i++) {
            var reg = regex_1[_i];
            var match = reg[0].exec(line);
            if (match && match.index < start) {
                start = match.index;
                color = reg[1];
                length_1 = match[0].length;
            }
        }
        colorized += line.substring(0, start);
        if (color) {
            colorized += line.substr(start, length_1)[color];
        }
        line = line.substr(start + length_1);
    }
    return colorized;
}
function createReadLine() {
    return readline.createInterface({
        input: process.stdin,
        output: process.stdout,
        colorize: colorize,
        completer: function (line) {
            var code = multilineBuffer + '\n' + line;
            return service_1.completer(code);
        }
    });
}
// Much of this function is from repl.REPLServer.createContext
function createContext() {
    var builtinLibs = require('repl')._builtinLibs;
    var context;
    context = vm.createContext();
    util_1.assign(context, global);
    context.console = new console_1.Console(process.stdout);
    context.global = context;
    context.global.global = context;
    context.module = new Module('<repl>');
    try {
        // hack for require.resolve("./relative") to work properly.
        context.module.filename = path.resolve('repl');
    }
    catch (e) {
        // path.resolve('repl') fails when the current working directory has been
        // deleted.  Fall back to the directory name of the (absolute) executable
        // path.  It's not really correct but what are the alternatives?
        var dirname = path.dirname(process.execPath);
        context.module.filename = path.resolve(dirname, 'repl');
    }
    context.module.paths = Module._nodeModulePaths(context.module.filename);
    context.paths = Module._resolveLookupPaths(process.cwd(), context.module)[1];
    var req = context.module.require.bind(context.module);
    context.require = req;
    // Lazy load modules on use
    builtinLibs.forEach(function (name) {
        Object.defineProperty(context, name, {
            get: function () {
                var lib = require(name);
                context[name] = lib;
                return lib;
            },
            // Allow creation of globals of the same name
            set: function (val) {
                delete context[name];
                context[name] = val;
            },
            configurable: true
        });
    });
    return context;
}
function printHelp() {
    console.log("\ntsun repl commands\n:type symbol       print the type of an identifier\n:doc  symbol       print the documentation for an identifier\n:clear             clear all the code\n:print             print code input so far\n:help              print this manual\n:paste             enter paste mode\n:load filename     source typescript file in current context".blue);
    if (argv.dere) {
        console.log(':baka              Who would like some pervert like you, baka~'.blue);
    }
}
var context = createContext();
function startEvaluate(code) {
    multilineBuffer = '';
    var allDiagnostics = service_1.getDiagnostics(code);
    if (allDiagnostics.length) {
        console.warn(allDiagnostics.join('\n').bold.red);
        if (exports.defaultPrompt != '> ') {
            console.log('');
            console.log(exports.defaultPrompt, 'URUSAI URUSAI URUSAI'.magenta);
            console.log('');
        }
        return repl(exports.defaultPrompt);
    }
    var current = service_1.getCurrentCode();
    if (verbose) {
        console.log(current.green);
    }
    try {
        var result = vm.runInContext(current, context);
        console.log(util.inspect(result, false, 2, true));
    }
    catch (e) {
        console.log(e.stack);
    }
}
function waitForMoreLines(code, indentLevel) {
    if (/\n{2}$/.test(code)) {
        console.log('You typed two blank lines! start new command'.yellow);
        multilineBuffer = '';
        return repl(exports.defaultPrompt);
    }
    var nextPrompt = '';
    for (var i = 0; i < indentLevel; i++) {
        nextPrompt += exports.moreLinesPrompt;
    }
    multilineBuffer = code;
    repl(nextPrompt);
}
function replLoop(_, code) {
    code = multilineBuffer + '\n' + code;
    var diagnostics = service_1.testSyntacticError(code);
    if (diagnostics.length === 0) {
        startEvaluate(code);
        repl(exports.defaultPrompt);
    }
    else {
        var openCurly = (code.match(/\{/g) || []).length;
        var closeCurly = (code.match(/\}/g) || []).length;
        var openParen = (code.match(/\(/g) || []).length;
        var closeParen = (code.match(/\)/g) || []).length;
        // at lease one indent in multiline
        var indentLevel = (openCurly - closeCurly + openParen - closeParen) || 1;
        waitForMoreLines(code, indentLevel || 1);
    }
}
function addLine(line) {
    multilineBuffer += '\n' + line;
}
function enterPasteMode() {
    console.log('// entering paste mode, press ctrl-d to evaluate'.cyan);
    console.log('');
    var oldPrompt = exports.defaultPrompt;
    rl.setPrompt('');
    rl.on('line', addLine);
    rl.once('close', function () {
        console.log('evaluating...'.cyan);
        rl.removeListener('line', addLine);
        startEvaluate(multilineBuffer);
        rl = createReadLine();
        repl(exports.defaultPrompt = oldPrompt);
    });
}
function loadFile(filename) {
    try {
        var filePath = path.resolve(filename);
        var fileContents = fs.readFileSync(filePath, 'utf8');
        if (verbose) {
            console.log(("loading file: " + filePath).cyan);
            console.log(colorize(fileContents));
            console.log('evaluating...'.cyan);
        }
        startEvaluate(fileContents);
    }
    catch (e) {
        console.log(e);
    }
}
function getSource(name) {
    var declarations = service_1.getDeclarations();
    for (var file in declarations) {
        var names = declarations[file];
        if (names[name]) {
            var decl = names[name];
            var pager = process.env.PAGER;
            var parent_1 = decl[0].parent;
            var text = parent_1 ? parent_1.getFullText() : '';
            if (!pager || text.split('\n').length < 24) {
                console.log(text);
                repl(exports.defaultPrompt);
                return;
            }
            process.stdin.pause();
            var tty = require('tty');
            tty.setRawMode(false);
            var temp = require('temp');
            var tempFile = temp.openSync('DUMMY_FILE' + Math.random());
            fs.writeFileSync(tempFile.path, text);
            var display = child_process.spawn('less', [tempFile.path], {
                'stdio': [0, 1, 2]
            });
            display.on('exit', function () {
                temp.cleanupSync();
                tty.setRawMode(true);
                process.stdin.resume();
                repl(exports.defaultPrompt);
            });
            return;
        }
    }
    console.log(("identifier " + name + " not found").yellow);
}
// main loop
function repl(prompt) {
    'use strict';
    rl.question(prompt, function (code) {
        if (/^:(type|doc)/.test(code)) {
            var identifier = code.split(' ')[1];
            if (!identifier) {
                console.log(':type command need names!'.red);
                return repl(prompt);
            }
            var ret = service_1.getType(identifier, code.indexOf('doc') === 1);
            if (ret) {
                console.log(colorize(ret));
            }
            else {
                console.log(("no info for \"" + identifier + "\" is found").yellow);
            }
            return repl(prompt);
        }
        if (/^:source/.test(code)) {
            var identifier = code.split(' ')[1];
            if (!identifier) {
                console.log(':source command need names!'.red);
                return repl(prompt);
            }
            getSource(identifier);
            return;
        }
        if (/^:help/.test(code)) {
            printHelp();
            return repl(prompt);
        }
        if (/^:clear/.test(code)) {
            service_1.clearHistory();
            multilineBuffer = '';
            context = createContext();
            return repl(exports.defaultPrompt);
        }
        if (/^:print/.test(code)) {
            console.log(colorize(service_1.acceptedCodes));
            return repl(prompt);
        }
        if (/^:paste/.test(code) && !multilineBuffer) {
            return enterPasteMode();
        }
        if (/^:load/.test(code) && !multilineBuffer) {
            var filename = code.split(' ')[1];
            if (!filename) {
                console.log(':load: file name expected'.red);
                return repl(prompt);
            }
            loadFile(filename);
            return repl(prompt);
        }
        if (argv.dere && /^:baka/.test(code)) {
            exports.defaultPrompt = 'ξ(ﾟ⊿ﾟ)ξ> ';
            exports.moreLinesPrompt = 'ζ(///*ζ) ';
            return repl(exports.defaultPrompt);
        }
        replLoop(prompt, code);
    });
}
exports.repl = repl;
function startRepl() {
    repl(exports.defaultPrompt);
}
exports.startRepl = startRepl;
