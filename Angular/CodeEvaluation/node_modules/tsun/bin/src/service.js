"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var path = require("path");
var fs_1 = require("fs");
var diff = require("diff");
var util_1 = require("./util");
// codes has been accepted by service, as opposed to codes in buffer and user input
// if some action fails to compile, acceptedCodes will be rolled-back
exports.acceptedCodes = getInitialCommands();
// a counter indicating repl edition history, every action will increment it
var versionCounter = 0;
function findConfigFile(searchPath) {
    while (true) {
        var fileName = path.join(searchPath, "tsconfig.json");
        if (fs_1.existsSync(fileName)) {
            return fileName;
        }
        var parentPath = path.dirname(searchPath);
        if (parentPath === searchPath) {
            break;
        }
        searchPath = parentPath;
    }
    return undefined;
}
var CWD = process.cwd();
var DEFAULT_OPTIONS = {
    target: ts.ScriptTarget.ES5,
    newLine: ts.NewLineKind.LineFeed,
    experimentalDecorators: true,
    emitDecoratorMetadata: true,
    noUnusedLocals: false,
    configFilePath: path.join(CWD, 'tsconfig.json'),
};
// these option must be set in repl environment
var OVERRIDE_OPTIONS = {
    module: ts.ModuleKind.CommonJS,
    noEmitHelpers: true,
    noUnusedLocals: false,
    sourceMap: false,
    noEmit: false
};
function compileOption() {
    var configFile = findConfigFile(process.cwd());
    if (!configFile) {
        return function () { return DEFAULT_OPTIONS; };
    }
    var configText = fs_1.readFileSync(configFile, 'utf8');
    var result = ts.parseConfigFileTextToJson(configFile, configText);
    if (result.error) {
        return function () { return DEFAULT_OPTIONS; };
    }
    var optionOrError = ts.convertCompilerOptionsFromJson(result.config.compilerOptions, path.dirname(configFile));
    if (optionOrError.errors.length) {
        return function () { return DEFAULT_OPTIONS; };
    }
    var options = optionOrError.options;
    // override some impossible option
    util_1.assign(options, OVERRIDE_OPTIONS);
    return function () { return options; };
}
var resolvedOpt = compileOption()();
var DUMMY_FILE = resolvedOpt.rootDir ? resolvedOpt.rootDir + 'TSUN.repl.generated.ts' : 'TSUN.repl.generated.ts';
var serviceHost = {
    getCompilationSettings: compileOption(),
    getScriptFileNames: function () { return [DUMMY_FILE]; },
    getScriptVersion: function (fileName) {
        return fileName === DUMMY_FILE ? versionCounter.toString() : '1';
    },
    getScriptSnapshot: function (fileName) {
        try {
            var text = fileName === DUMMY_FILE
                ? exports.acceptedCodes
                : fs_1.readFileSync(fileName).toString();
            return ts.ScriptSnapshot.fromString(text);
        }
        catch (e) {
            return undefined;
        }
    },
    getCurrentDirectory: function () { return CWD; },
    getDirectories: ts.sys.getDirectories,
    directoryExists: ts.sys.directoryExists,
    getDefaultLibFileName: function (options) { return ts.getDefaultLibFilePath(options); }
};
var service = ts.createLanguageService(serviceHost);
exports.getDeclarations = (function () {
    var declarations = {};
    var declFiles = getDeclarationFiles();
    for (var _i = 0, declFiles_1 = declFiles; _i < declFiles_1.length; _i++) {
        var file = declFiles_1[_i];
        var text = fs_1.readFileSync(file, 'utf8');
        declarations[file] = collectDeclaration(ts.createSourceFile(file, text, ts.ScriptTarget.Latest));
    }
    return function (cached) {
        if (cached === void 0) { cached = false; }
        if (!cached) {
            declarations[DUMMY_FILE] = collectDeclaration(ts.createSourceFile(DUMMY_FILE, exports.acceptedCodes, ts.ScriptTarget.Latest));
        }
        return declarations;
    };
})();
function getDeclarationFiles() {
    var libPaths = [path.resolve(__dirname, '../../node_modules/@types/node/index.d.ts')];
    try {
        var typings = path.join(process.cwd(), './typings');
        var dirs = fs_1.readdirSync(typings);
        for (var _i = 0, dirs_1 = dirs; _i < dirs_1.length; _i++) {
            var dir = dirs_1[_i];
            if (!/\.d\.ts$/.test(dir))
                continue;
            var p = path.join(typings, dir);
            if (fs_1.statSync(p).isFile()) {
                libPaths.push(p);
            }
        }
    }
    catch (e) {
    }
    return libPaths;
}
function getInitialCommands() {
    return getDeclarationFiles()
        .map(function (dir) { return "/// <reference path=\"" + dir + "\" />\n"; }).join();
}
// private api hacks
function collectDeclaration(sourceFile) {
    var decls = sourceFile.getNamedDeclarations();
    var ret = {};
    for (var decl in decls) {
        ret[decl] = Array.isArray(decls[decl]) && decls[decl].map(function (t) { return t.name; });
    }
    return ret;
}
function completer(line) {
    // append new line to get completions, then revert new line
    versionCounter++;
    var originalCodes = exports.acceptedCodes;
    exports.acceptedCodes += line;
    if (':' === line[0]) {
        var candidates_1 = ['type', 'detail', 'source', 'paste', 'clear', 'print', 'help'];
        candidates_1 = candidates_1.map(function (c) { return ':' + c; }).filter(function (c) { return c.indexOf(line) >= 0; });
        return [candidates_1, line.trim()];
    }
    var completions = service.getCompletionsAtPosition(DUMMY_FILE, exports.acceptedCodes.length);
    if (!completions) {
        exports.acceptedCodes = originalCodes;
        return [[], line];
    }
    var prefix = /[A-Za-z_$]+$/.exec(line);
    var candidates = [];
    if (prefix) {
        var prefixStr_1 = prefix[0];
        candidates = completions.entries.filter(function (entry) {
            var name = entry.name;
            return name.substr(0, prefixStr_1.length) == prefixStr_1;
        }).map(function (entry) { return entry.name; });
    }
    else {
        candidates = completions.entries.map(function (entry) { return entry.name; });
    }
    exports.acceptedCodes = originalCodes;
    return [candidates, prefix ? prefix[0] : line];
}
exports.completer = completer;
function getType(name, detailed) {
    versionCounter++;
    var originalCodes = exports.acceptedCodes;
    exports.acceptedCodes += '\n;' + name;
    var typeInfo = service.getQuickInfoAtPosition(DUMMY_FILE, exports.acceptedCodes.length - 1);
    var ret = '';
    if (typeInfo) {
        ret = detailed
            ? ts.displayPartsToString(typeInfo.documentation)
            : ts.displayPartsToString(typeInfo.displayParts);
    }
    exports.acceptedCodes = originalCodes;
    return ret;
}
exports.getType = getType;
function getDiagnostics(code) {
    var fallback = exports.acceptedCodes;
    exports.acceptedCodes += code;
    versionCounter++;
    var allDiagnostics = service.getCompilerOptionsDiagnostics()
        .concat(service.getSemanticDiagnostics(DUMMY_FILE));
    var ret = allDiagnostics.map(function (diagnostic) {
        var message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
        return message;
    });
    if (ret.length)
        exports.acceptedCodes = fallback;
    return ret;
}
exports.getDiagnostics = getDiagnostics;
var lastOutput = '';
function getCurrentCode() {
    var emit = service.getEmitOutput(DUMMY_FILE);
    var output = emit.outputFiles[0].text;
    var changes = diff.diffLines(lastOutput, output);
    var ret = changes.filter(function (c) { return c.added; }).map(function (c) { return c.value; }).join('\n');
    lastOutput = output;
    return ret;
}
exports.getCurrentCode = getCurrentCode;
function testSyntacticError(code) {
    var fallback = exports.acceptedCodes;
    versionCounter++;
    exports.acceptedCodes += code;
    var diagnostics = service.getSyntacticDiagnostics(DUMMY_FILE);
    exports.acceptedCodes = fallback;
    return diagnostics;
}
exports.testSyntacticError = testSyntacticError;
function clearHistory() {
    exports.acceptedCodes = getInitialCommands();
    lastOutput = '';
}
exports.clearHistory = clearHistory;
